var searchIndex = JSON.parse('{\
"bitfrob":{"doc":"A crate to help with bit manipulation of integers.","t":[18,18,18,3,3,3,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,3,11,11],"n":["OUT","OUT","OUT","U16ConstRegionMask","U32ConstRegionMask","U8ConstRegionMask","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","clone","clone","clone","clone","cmp","cmp","cmp","cmp","default","default","default","default","eq","eq","eq","eq","fmt","fmt","fmt","fmt","from","from","from","from","hash","hash","hash","hash","high","into","into","into","into","low","ne","partial_cmp","partial_cmp","partial_cmp","partial_cmp","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","u16_get_bit","u16_get_region","u16_get_value","u16_region_mask","u16_with_bit","u16_with_region","u16_with_value","u32_get_bit","u32_get_region","u32_get_value","u32_region_mask","u32_with_bit","u32_with_region","u32_with_value","u8_get_bit","u8_get_region","u8_get_value","u8_region_mask","u8_with_bit","u8_with_region","u8_with_value","u8x2","with_high","with_low"],"q":["bitfrob","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["The computed bit mask.","The computed bit mask.","The computed bit mask.","Like <code>u16_region_mask</code>, but forces the value into an …","Like <code>u32_region_mask</code>, but forces the value into an …","Like <code>u8_region_mask</code>, but forces the value into an …","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","","The upper byte","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","The lower byte","","","","","","","","","","","","","","","","","","Gets the <code>B</code> bit.","Gets a <code>L</code> to <code>H</code> (inclusive) bit region of the value.","Like <code>u16_get_region</code> but the output is shifted down …","Generates a bit mask where all bits in the region are 1.","Replaces the <code>B</code> bit.","Replaces a <code>L</code> to <code>H</code> (inclusive) bit region of the value.","Like <code>u16_with_region</code> but the value is shifted up …","Gets the <code>B</code> bit.","Gets a <code>L</code> to <code>H</code> (inclusive) bit region of the value.","Like <code>u32_get_region</code> but the output is shifted down …","Generates a bit mask where all bits in the region are 1.","Replaces the <code>B</code> bit.","Replaces a <code>L</code> to <code>H</code> (inclusive) bit region of the value.","Like <code>u32_with_region</code> but the value is shifted up …","Gets the <code>B</code> bit.","Gets a <code>L</code> to <code>H</code> (inclusive) bit region of the value.","Like <code>u8_get_region</code> but the output is shifted down …","Generates a bit mask where all bits in the region are 1.","Replaces the <code>B</code> bit.","Replaces a <code>L</code> to <code>H</code> (inclusive) bit region of the value.","Like <code>u8_with_region</code> but the value is shifted up …","Two <code>u8</code> values packed as a <code>u16</code>.","Updates the upper byte value, returning the new <code>u8x2</code>","Updates the lower byte value, returning the new <code>u8x2</code>"],"i":[1,2,3,0,0,0,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,4,1,2,3,4,4,4,1,2,3,4,1,2,3,4,1,2,3,4,1,2,3,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,4],"f":[0,0,0,0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[1,1],[2,2],[3,3],[4,4],[[1,1],5],[[2,2],5],[[3,3],5],[[4,4],5],[[],1],[[],2],[[],3],[[],4],[[1,1],6],[[2,2],6],[[3,3],6],[[4,4],6],[[1,7],8],[[2,7],8],[[3,7],8],[[4,7],8],[[]],[[]],[[]],[[]],[1],[2],[3],[4],[4,9],[[]],[[]],[[]],[[]],[4,9],[[4,4],6],[[1,1],[[10,[5]]]],[[2,2],[[10,[5]]]],[[3,3],[[10,[5]]]],[[4,4],[[10,[5]]]],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],12],[[],12],[[],12],[[],12],[13,6],[13,13],[13,13],[[14,14],13],[[13,6],13],[[13,13],13],[[13,13],13],[14,6],[14,14],[14,14],[[14,14],14],[[14,6],14],[[14,14],14],[[14,14],14],[9,6],[9,9],[9,9],[[14,14],9],[[9,6],9],[[9,9],9],[[9,9],9],0,[[4,9],4],[[4,9],4]],"p":[[3,"U32ConstRegionMask"],[3,"U16ConstRegionMask"],[3,"U8ConstRegionMask"],[3,"u8x2"],[4,"Ordering"],[15,"bool"],[3,"Formatter"],[6,"Result"],[15,"u8"],[4,"Option"],[4,"Result"],[3,"TypeId"],[15,"u16"],[15,"u32"]]},\
"bytemuck":{"doc":"This crate gives small utilities for casting between plain …","t":[13,8,2,8,16,18,18,8,13,8,4,8,13,13,8,8,8,11,11,5,5,5,5,5,5,5,0,11,11,11,11,11,5,5,11,11,11,11,11,11,14,14,11,11,11,11,11,11,11,11,11,11,5,5,5,5,5,5,5,5,11,5,5,11,5,11,11,11,11,11,11,11,11,11,11,11,11,11,16,8,4,13,13,11,11,5,5,5,5,5,11,11,11,11,11,11,5,5,11,11,10,11,5,5,5,5,5,5,11,5,5,11,5,11,12],"n":["AlignmentMismatch","AnyBitPattern","CheckedBitPattern","Contiguous","Int","MAX_VALUE","MIN_VALUE","NoUninit","OutputSliceWouldHaveSlop","Pod","PodCastError","PodInOption","SizeMismatch","TargetAlignmentGreaterAndInputNotAligned","TransparentWrapper","Zeroable","ZeroableInOption","borrow","borrow_mut","bytes_of","bytes_of_mut","cast","cast_mut","cast_ref","cast_slice","cast_slice_mut","checked","clone","eq","fmt","fmt","from","from_bytes","from_bytes_mut","from_integer","from_integer","hash","into","into_integer","into_integer","offset_of","offset_of","peel","peel","peel_mut","peel_mut","peel_ref","peel_ref","peel_slice","peel_slice","peel_slice_mut","peel_slice_mut","pod_align_to","pod_align_to_mut","pod_read_unaligned","try_cast","try_cast_mut","try_cast_ref","try_cast_slice","try_cast_slice_mut","try_from","try_from_bytes","try_from_bytes_mut","try_into","try_pod_read_unaligned","type_id","wrap","wrap","wrap_mut","wrap_mut","wrap_ref","wrap_ref","wrap_slice","wrap_slice","wrap_slice_mut","wrap_slice_mut","zeroed","zeroed","Bits","CheckedBitPattern","CheckedCastError","InvalidBitPattern","PodCastError","borrow","borrow_mut","cast","cast_mut","cast_ref","cast_slice","cast_slice_mut","clone","eq","fmt","fmt","from","from","from_bytes","from_bytes_mut","hash","into","is_valid_bit_pattern","ne","pod_read_unaligned","try_cast","try_cast_mut","try_cast_ref","try_cast_slice","try_cast_slice_mut","try_from","try_from_bytes","try_from_bytes_mut","try_into","try_pod_read_unaligned","type_id","0"],"q":["bytemuck","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","bytemuck::checked","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","bytemuck::checked::CheckedCastError"],"d":["For this type of cast the alignments must be exactly the …","Marker trait for “plain old data” types that are valid …","","A trait indicating that:","The primitive integer type with an identical …","The upper <em>inclusive</em> bound for valid instances of this type.","The lower <em>inclusive</em> bound for valid instances of this type.","Marker trait for “plain old data” types with no uninit …","If the element size changes then the output slice changes …","Marker trait for “plain old data”.","The things that can go wrong when casting between <code>Pod</code> data …","Trait for types which are Pod when wrapped in Option.","When casting a slice you can’t convert between ZST …","You tried to cast a slice to an element type with a higher …","A trait which indicates that a type is a …","Trait for types that can be safely created with <code>zeroed</code>.","Trait for types which are Zeroable when wrapped in Option.","","","Re-interprets <code>&amp;T</code> as <code>&amp;[u8]</code>.","Re-interprets <code>&amp;mut T</code> as <code>&amp;mut [u8]</code>.","Cast <code>T</code> into <code>U</code>","Cast <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Cast <code>&amp;T</code> into <code>&amp;U</code>.","Cast <code>&amp;[A]</code> into <code>&amp;[B]</code>.","Cast <code>&amp;mut [T]</code> into <code>&amp;mut [U]</code>.","Checked versions of the casting functions exposed in crate …","","","","","Returns the argument unchanged.","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","If <code>value</code> is within the range for valid instances of this …","If <code>value</code> is within the range for valid instances of this …","","Calls <code>U::from(self)</code>.","Perform the conversion from <code>C</code> into the underlying integral …","Perform the conversion from <code>C</code> into the underlying integral …","Find the offset in bytes of the given <code>$field</code> of <code>$Type</code>. …","Find the offset in bytes of the given <code>$field</code> of <code>$Type</code>. …","Convert the wrapper type into the inner type.","Convert the wrapper type into the inner type.","Convert a mutable reference to the wrapper type into a …","Convert a mutable reference to the wrapper type into a …","Convert a reference to the wrapper type into a reference …","Convert a reference to the wrapper type into a reference …","Convert a slice to the wrapped type into a slice to the …","Convert a slice to the wrapped type into a slice to the …","Convert a mutable slice to the wrapped type into a mutable …","Convert a mutable slice to the wrapped type into a mutable …","As <code>align_to</code>, but safe because of the <code>Pod</code> bound.","As <code>align_to_mut</code>, but safe because of the <code>Pod</code> bound.","Reads the slice into a <code>T</code> value.","Try to cast <code>T</code> into <code>U</code>.","Try to convert a <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Try to convert a <code>&amp;T</code> into <code>&amp;U</code>.","Try to convert <code>&amp;[A]</code> into <code>&amp;[B]</code> (possibly with a change in …","Try to convert <code>&amp;mut [A]</code> into <code>&amp;mut [B]</code> (possibly with a …","","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","","Reads from the bytes as if they were a <code>T</code>.","","Convert the inner type into the wrapper type.","Convert the inner type into the wrapper type.","Convert a mutable reference to the inner type into a …","Convert a mutable reference to the inner type into a …","Convert a reference to the inner type into a reference to …","Convert a reference to the inner type into a reference to …","Convert a slice to the inner type into a slice to the …","Convert a slice to the inner type into a slice to the …","Convert a mutable slice to the inner type into a mutable …","Convert a mutable slice to the inner type into a mutable …","Calls <code>zeroed</code>.","Calls <code>zeroed</code>.","<code>Self</code> <em>must</em> have the same layout as the specified <code>Bits</code> …","A marker trait that allows types that have some invalid …","The things that can go wrong when casting between …","When casting to a <code>CheckedBitPattern</code> type, it is possible …","An error occurred during a true-[<code>Pod</code>] cast","","","Cast <code>T</code> into <code>U</code>","Cast <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Cast <code>&amp;T</code> into <code>&amp;U</code>.","Cast <code>&amp;[A]</code> into <code>&amp;[B]</code>.","Cast <code>&amp;mut [T]</code> into <code>&amp;mut [U]</code>.","","","","","Returns the argument unchanged.","","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","","Calls <code>U::from(self)</code>.","If this function returns true, then it must be valid to …","","Reads the slice into a <code>T</code> value.","Try to cast <code>T</code> into <code>U</code>.","Try to convert a <code>&amp;mut T</code> into <code>&amp;mut U</code>.","Try to convert a <code>&amp;T</code> into <code>&amp;U</code>.","Try to convert <code>&amp;[A]</code> into <code>&amp;[B]</code> (possibly with a change in …","Try to convert <code>&amp;mut [A]</code> into <code>&amp;mut [B]</code> (possibly with a …","","Re-interprets <code>&amp;[u8]</code> as <code>&amp;T</code>.","Re-interprets <code>&amp;mut [u8]</code> as <code>&amp;mut T</code>.","","Reads from the bytes as if they were a <code>T</code>.","",""],"i":[3,0,0,0,12,12,12,0,3,0,0,0,3,3,0,0,0,3,3,0,0,0,0,0,0,0,0,3,3,3,3,3,0,0,12,12,3,3,12,12,0,0,13,13,13,13,13,13,13,13,13,13,0,0,0,0,0,0,0,0,3,0,0,3,0,3,13,13,13,13,13,13,13,13,13,13,14,14,10,0,0,11,11,11,11,0,0,0,0,0,11,11,11,11,11,11,0,0,11,11,10,11,0,0,0,0,0,0,11,0,0,11,0,11,15],"f":[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[]],[[]],[1,2],[[]],[[]],[[]],[[]],0,[3,3],[[3,3],4],[[3,5],6],[[3,5],6],[[]],[[]],[[]],[[],7],[[],7],[3],[[]],[[]],[[]],0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[],2],[1,[[8,[2,3]]]],[[],[[8,[3]]]],[[],[[8,[3]]]],[[],[[8,[3]]]],[[],[[8,[3]]]],[[],8],[[],[[8,[3]]]],[[],[[8,[3]]]],[[],8],[[],[[8,[2,3]]]],[[],9],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],0,0,0,0,0,[[]],[[]],[1,10],[[]],[[]],[[]],[[]],[11,11],[[11,11],4],[[11,5],6],[[11,5],6],[[]],[3,11],[[]],[[]],[11],[[]],[[],4],[[11,11],4],[[],2],[1,[[8,[10,11]]]],[[],[[8,[11]]]],[[],[[8,[11]]]],[[],[[8,[11]]]],[[],[[8,[11]]]],[[],8],[[],[[8,[11]]]],[[],[[8,[11]]]],[[],8],[[],[[8,[10,11]]]],[[],9],0],"p":[[8,"NoUninit"],[8,"AnyBitPattern"],[4,"PodCastError"],[15,"bool"],[3,"Formatter"],[6,"Result"],[4,"Option"],[4,"Result"],[3,"TypeId"],[8,"CheckedBitPattern"],[4,"CheckedCastError"],[8,"Contiguous"],[8,"TransparentWrapper"],[8,"Zeroable"],[13,"PodCastError"]]},\
"gamecrab":{"doc":"","t":[0,3,3,3,3,3,12,12,12,12,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,11,11,11,11,11,12,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,12,11,11,11,11,11,12,11,11,11,11,11,11,11,11,12,11,11,11,11,11,11,11,11,11,11,11,12,12,11,11,11,11,12,12,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11,11],"n":["cpu","Cpu","CpuByteFields","Flags","Reg16","Reg8","a","af","b","bc","borrow","borrow","borrow","borrow","borrow","borrow_mut","borrow_mut","borrow_mut","borrow_mut","borrow_mut","c","c","clone","clone","clone","clone","clone","clone_into","clone_into","clone_into","clone_into","clone_into","cmp","cmp","cmp","cmp","cmp","d","de","default","default","default","default","default","deref","deref_mut","e","eq","eq","eq","eq","eq","flags","fmt","fmt","fmt","fmt","fmt","from","from","from","from","from","h","h","hash","hash","hash","hash","hash","hl","into","into","into","into","into","is_valid_bit_pattern","is_valid_bit_pattern","is_valid_bit_pattern","l","n","ne","ne","ne","ne","ne","partial_cmp","partial_cmp","partial_cmp","partial_cmp","partial_cmp","pc","pc","set_c","set_h","set_n","set_z","sp","sp","to_owned","to_owned","to_owned","to_owned","to_owned","try_from","try_from","try_from","try_from","try_from","try_into","try_into","try_into","try_into","try_into","type_id","type_id","type_id","type_id","type_id","z"],"q":["gamecrab","gamecrab::cpu","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"d":["","Simulates the Game Boy’s LR35902 CPU.","A view of the CPU with the data registers broken into …","The flags register.","A 16-bit CPU register.","An 8-bit CPU register.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","Returns the argument unchanged.","","","","","","","","","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","Calls <code>U::from(self)</code>.","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","","",""],"i":[0,0,0,0,0,0,4,3,4,3,3,4,5,6,1,3,4,5,6,1,1,4,3,4,5,6,1,3,4,5,6,1,3,4,5,6,1,4,3,3,4,5,6,1,3,3,4,3,4,5,6,1,4,3,4,5,6,1,3,4,5,6,1,1,4,3,4,5,6,1,3,3,4,5,6,1,5,6,1,4,1,3,4,5,6,1,3,4,5,6,1,3,4,1,1,1,1,3,4,3,4,5,6,1,3,4,5,6,1,3,4,5,6,1,3,4,5,6,1,1],"f":[0,0,0,0,0,0,0,0,0,0,[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[[]],[1,2],0,[3,3],[4,4],[5,5],[6,6],[1,1],[[]],[[]],[[]],[[]],[[]],[[3,3],7],[[4,4],7],[[5,5],7],[[6,6],7],[[1,1],7],0,0,[[],3],[[],4],[[],5],[[],6],[[],1],[3],[3],0,[[3,3],2],[[4,4],2],[[5,5],2],[[6,6],2],[[1,1],2],0,[[3,8],9],[[4,8],9],[[5,8],9],[[6,8],9],[[1,8],9],[[]],[[]],[[]],[[]],[[]],[1,2],0,[3],[4],[5],[6],[1],0,[[]],[[]],[[]],[[]],[[]],[[],2],[[],2],[[],2],0,[1,2],[[3,3],2],[[4,4],2],[[5,5],2],[[6,6],2],[[1,1],2],[[3,3],[[10,[7]]]],[[4,4],[[10,[7]]]],[[5,5],[[10,[7]]]],[[6,6],[[10,[7]]]],[[1,1],[[10,[7]]]],0,0,[[1,2]],[[1,2]],[[1,2]],[[1,2]],0,0,[[]],[[]],[[]],[[]],[[]],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],11],[[],12],[[],12],[[],12],[[],12],[[],12],[1,2]],"p":[[3,"Flags"],[15,"bool"],[3,"Cpu"],[3,"CpuByteFields"],[3,"Reg16"],[3,"Reg8"],[4,"Ordering"],[3,"Formatter"],[6,"Result"],[4,"Option"],[4,"Result"],[3,"TypeId"]]}\
}');
if (typeof window !== 'undefined' && window.initSearch) {window.initSearch(searchIndex)};
if (typeof exports !== 'undefined') {exports.searchIndex = searchIndex};
